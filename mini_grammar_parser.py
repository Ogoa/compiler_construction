from scanner import lex_analyze
from tree_node import Node
import re

class Parser:
    """Implementation of a class with methods to parse the token string returned by the scanner
    Each method corresponds to a non-terminal in the refactored BNF
    The token string generated by the scanner is taken as input in the constructor
    """
    
    def __init__(self, input_string):
        """Class constructor
        
        Args:
            input_string (List<Tuple<str, *>>): Token string returned by the scanner
        """
        self.tokens = lex_analyze(input_string)  # Token string returned from the scanner as a List object (token, lexeme)
        self.current_token = None  # Current token being consumed
        self.index = 0  # Index of the current token in the list of tokens
        self.errors = []  # List of syntactical errors encountered by the parser
        
    def parse(self):
        """Starts the parsing process.
        This is the method invoked from the caller program
        
        Return:
            (Node): Head node of the parse tree that has been built
        """
        self.consume_token()
        parse_tree = self.program()
        if not self.errors:
            return parse_tree
        else:
            return None
        
    def consume_token(self):
        """Advances the 'current_token' pointer to the next token in the token string
        """
        if self.index < len(self.tokens):
            self.current_token = self.tokens[self.index]  # Set the current token as the tuple in the current index of the token string
            self.index += 1
        else:
            self.current_token = None
        
    def program(self):
        """Starts off the parsing process from the start symbol, by calling `statement_list()`
        
        Return:
            (Node): A node representing all tokens from the start symbol
        """
        program_node = Node("program")
        statement_list_node = self.statement_list()
        if statement_list_node:
            program_node.add_child(statement_list_node)
        return program_node

    def statement_list(self):
        """Parses a list of statements by iteratively calling `statement()` until there are no more tokens
        Return:
            (Node): A node representing all tokens under a `statement_list` non-terminal
        """
        statement_list_node = Node("statement_list")
        while self.current_token:
            statement_node = self.statement()
            if statement_node:
                statement_list_node.add_child(statement_node)
            else:
                break
        return statement_list_node

    def statement(self):
        """Parses a single statement. This can be an assignment_statement, conditional_statement, or loop_statement

        Returns:
            (Node): A node representing all tokens from the `statement` non-terminal
        """
        statement_node = None
        if self.assignment_statement():
            statement_node = self.assignment_statement()
        elif self.conditional_statement():
            statement_node = self.conditional_statement()
        elif self.loop_statement():
            statement_node = self.loop_statement()
        else:
            self.consume_token()  # Advance token index if no statement matches
        return statement_node

    def assignment_statement(self):
        """Parses an assignment statement. It expects an `identifier` followed by an `=` sign then an `expression`

        Returns:
            (Node): A node representing all tokens under the `assignment_statement` non-terminal
        """
        assignment_node = None
        if self.match_token('IDENTIFIER'):
            identifier_node = Node("identifier", self.current_token[1])
            self.consume_token()
            self.expect_token('ASSIGNMENT_OPERATOR')
            assignment_operator_node = Node("assignment_operator", self.current_token[1])
            self.consume_token()
            expression_node = self.expression()
            if expression_node:
                assignment_node = Node("assignment_statement")
                assignment_node.add_child(identifier_node)
                assignment_node.add_child(assignment_operator_node)
                assignment_node.add_child(expression_node)
        return assignment_node

    def conditional_statement(self):
        """Parses a conditional statement. It expects a `logical_operator` followed by a `logical_expression`,
        then a `block` of statements, and optionally an `else` keyword followed by another `block`

        Returns:
            (Node): A node representing all tokens under the `conditional_statement` non-terminal
        """
        conditional_node = None
        if self.match_token('CONDITIONAL_KEYWORD'):
            conditional_node = Node("conditional_statement", self.current_token[1])
            self.consume_token()
            logical_expression_node = self.logical_expression()
            if logical_expression_node:
                conditional_node.add_child(logical_expression_node)
                block_node = self.block()
                if block_node:
                    conditional_node.add_child(block_node)
                    if self.match_token('CONDITIONAL_KEYWORD'):
                        self.consume_token()
                        else_block_node = self.block()
                        if else_block_node:
                            conditional_node.add_child(else_block_node)
        return conditional_node

    def loop_statement(self):
        """Parses a loop statement. It expects to see the `for` or `while` keywords followed by an 
        identifier, an expression, a colon, a newline, an indent, and a block of statements.

        Returns:
            (Node): A node representing all tokens under the `loop_statement` non-terminal
        """
        loop_node = None
        if self.match_token('LOOP_KEYWORD'):
            loop_node = Node("loop_statement", self.current_token[1])
            self.consume_token()
            if self.match_token('IDENTIFIER'):
                identifier_node = Node("identifier", self.current_token[1])
                loop_node.add_child(identifier_node)
                self.consume_token()
                self.expect_token('COLON')
                self.newline()
                self.indent()
                statement_list_node = self.statement_list()
                if statement_list_node:
                    loop_node.add_child(statement_list_node)
        return loop_node


    def match_token(self, expected_token_type):
        """Checks if the current token matches the expected token
        
        Args:
            expected_token_type (str): Token type expected
        
        Return:
            Boolean: true if a match is found otherwise false
        """
        #TODO: maybe remove self.current_token
        if self.current_token[0] == expected_token_type:
            return True
        else:
            return False

    def expect_token(self, expected_token_type):
        """Expects the current token to match the expected token type. If a match is found, it
        advances to the next token, otherwise an error message is added to the list of errors
        and attempts to recover by skipping over tokens until a valid point is reached

        Args:
            expected_token_type (str): the expected type of the current token as described in the grammar
        """
        if self.match_token(expected_token_type):
            self.consume_token()
        else:
            self.errors.append(f"Expected {expected_token_type}, found {self.current_token[0] if self.current_token else 'end of input'}")
            # Attempt to recover from error by skipping tokens until reaching a valid point
            while self.current_token and not self.match_token(expected_token_type):
                self.consume_token()


    def logical_expression(self):
        """Parses a logical expression. It expects to see a `logical_operator` between two `logical_terms`
        <logical_expression> ::= <logical_term> <logical_expression'>
        <logical_expression'> ::= <logical_operator> <logical_term> | ε
        
        Return:
            (Node): A node representing all tokens under the `logical_expression` non-terminal
        """
        logical_expression_node = Node("logical_expression")
        logical_term_node = self.logical_term()
        if logical_term_node:
            logical_expression_node.add_child(logical_term_node)
            while self.match_token('LOGICAL_OPERATOR'):
                logical_operator_node = Node("logical_operator", self.current_token[1])
                self.consume_token()
                logical_term_node = self.logical_term()
                if logical_term_node:
                    logical_expression_node.add_child(logical_operator_node)
                    logical_expression_node.add_child(logical_term_node)
        return logical_expression_node

    def logical_term(self):
        """Parses a logical term. It expects to see one or more `relations` separated by logical operators
        <logical_term> ::= <relation> <logical_term'>
        <logical_term'> ::= <logical_operator> <relation> | ε
        
        Return:
            (Node): A node representing all tokens under the `logical_term` non-terminal
        """
        logical_term_node = None
        if self.match_token('RELATION_OPERATOR') or self.match_token('NUMBER') or self.match_token('IDENTIFIER') or self.match_token('STRING_LITERAL') or self.match_token('OPENING_PARENTHESIS'):
            logical_term_node = Node("logical_term")
            self.consume_token()
        elif self.match_token('LOGICAL_EXPRESSION'):
            logical_term_node = Node("logical_expression")
            logical_expression_node = self.logical_expression()
            if logical_expression_node:
                logical_term_node.add_child(logical_expression_node)
        return logical_term_node

    def relation(self):
        """Parses a relation. Expects to see a `relational_operator` between two `expression`s
        <relation> ::= <expression> <relation_operator> <expression>
        """
        self.expression()
        self.relation_operator()
        self.expression()

    def expression(self):
        """Parses an expression. It expects to see one or more `term`s separated by an `arithmetic_operator`
        <expression> ::= <term> <expression'>
        <expression'> ::= <arithmetic_operator> <term> | ε
        
        Return:
            (Node): A node representing all tokens under the `expression` non-terminal
        """
        expression_node = Node("expression")
        term_node = self.term()
        if term_node:
            expression_node.add_child(term_node)
            while self.match_token('ARITHMETIC_OPERATOR'):
                arithmetic_operator_node = Node("arithmetic_operator", self.current_token[1])
                self.consume_token()
                term_node = self.term()
                if term_node:
                    expression_node.add_child(arithmetic_operator_node)
                    expression_node.add_child(term_node)
        return expression_node

    def term(self):
        """Parses a term. It expects to see one or more `factor` separated by an `arithmetic_operator`
        <term> ::= <factor> <term'>
        <term'> ::= <arithmetic_operator> <factor> | ε
        
        Return:
            (Node): A node representing all tokens under the `term` non-terminal
        """
        term_node = Node("term")
        factor_node = self.factor()
        if factor_node:
            term_node.add_child(factor_node)
            while self.match_token('ARITHMETIC_OPERATOR'):
                arithmetic_operator_node = Node("arithmetic_operator", self.current_token[1])
                self.consume_token()
                factor_node = self.factor()
                if factor_node:
                    term_node.add_child(arithmetic_operator_node)
                    term_node.add_child(factor_node)
        return term_node

    def factor(self):
        """Parses a factor. It expects a number, `identifier`, `string`, or `opening_parenthesis`, and 
        optionally a `logical_expression`
        <factor> ::= <number> | <identifier> | <string> | ( <expression> ) | <logical_expression>
        
        Return:
            (Node): A node representing all tokens under the `factor` non-terminal
        """
        factor_node = None
        if self.match_token('NUMBER'):
            factor_node = Node("number", self.current_token[1])
            self.consume_token()
        elif self.match_token('IDENTIFIER'):
            factor_node = Node("identifier", self.current_token[1])
            self.consume_token()
        elif self.match_token('STRING_LITERAL'):
            factor_node = Node("string_literal", self.current_token[1])
            self.consume_token()
        elif self.match_token('OPENING_PARENTHESIS'):
            self.consume_token()
            expression_node = self.expression()
            if expression_node:
                factor_node = expression_node
                self.expect_token('CLOSING_PARENTHESIS')
                self.consume_token()
        elif self.match_token('LOGICAL_EXPRESSION'):
            factor_node = self.logical_expression()
        else:
            self.errors.append(f"Invalid token {self.current_token[0]}")
            self.consume_token()
        return factor_node

    def relation_operator(self):
        """Expects a `relation_operator`
        <relation_operator> ::= == | != | < | <= | > | >=
        
        Return:
            (Node): A node representing all tokens under the `relation_operator` non-terminal
        """
        relation_operator_node = None
        if self.match_token('RELATION_OPERATOR'):
            relation_operator_node = Node("relation_operator", self.current_token[1])
            self.consume_token()
        return relation_operator_node

    def newline(self):
        """Expects a newline character
        """
        if self.match_token('NEWLINE'):
            self.consume_token()

    def indent(self):
        """Expects an indent"""
        if self.match_token('INDENT'):
            self.consume_token()

    def block(self):
        """Parses a block.
        <block> ::= <statement> | <statement_list>
        
        Return:
            (Node): A node representing all tokens under the `block` non-terminal
        """
        block_node = Node("block")
        self.indent()
        statement_list_node = self.statement_list()
        if statement_list_node:
            block_node.add_child(statement_list_node)
        return block_node
